#!/usr/bin/env python
"""
Pender pre-commit hook.

For more information see https://github.com/alexjurkiewicz/pender
"""

import os
import sys
import shutil
import subprocess
import tempfile
import logging
import yaml

if 'GIT_DIR' in os.environ:
    PENDER_NAME = os.path.basename(sys.argv[0]) + '.py'
else:
    PENDER_NAME = os.path.basename(sys.argv[0])
CONFIG_NAME = os.path.splitext(PENDER_NAME)[0] + '.yaml'

TERM_BOLD = '\033[1m'
TERM_END = '\033[0m'
TERM_RED = '\033[31m'
TERM_YELLOW = '\033[33m'
PENDER_EXIT_OK = 0
PENDER_EXIT_ERR = 1
PENDER_EXIT_VETO = 10
GIT_EXIT_OK = 0
GIT_EXIT_VETO = 1


class PenderError(Exception):
    """Simple wrapper."""

    pass


class PenderLoggingFormatter(logging.Formatter):
    """Custom log formatter.

    Colourise error/warning messages. Based off:
    http://stackoverflow.com/questions/1343227/can-pythons-logging-format-be-modified-depending-on-the-message-log-level
    """

    def __init__(self):
        """Set up simple override for err/warn messages."""
        self.base_fmt = "{pender}: %(message)s".format(pender=PENDER_NAME)
        self.err_fmt = "%s%s%s" % (TERM_BOLD + TERM_RED, self.base_fmt,
                                   TERM_END)
        self.warn_fmt = "%s%s%s" % (TERM_BOLD + TERM_YELLOW, self.base_fmt,
                                    TERM_END)
        logging.Formatter.__init__(self, self.base_fmt)

    def format(self, record):
        """Set the format string based on severity.

        This will also cause issues for logging errors generated by libs we
        use, but since we don't use libs skip the extra code to avoid this.
        """
        if record.levelno == logging.ERROR:
            self._fmt = self.err_fmt
        elif record.levelno == logging.WARN:
            self._fmt = self.warn_fmt
        else:
            self._fmt = self.base_fmt

        # Call the original formatter class to do the grunt work
        return logging.Formatter.format(self, record)


def load_config():
    """Load pre-commit.yaml."""
    if 'GIT_DIR' in os.environ:
        path = os.path.join(os.environ['GIT_DIR'], '..', CONFIG_NAME)
    else:
        path = CONFIG_NAME
    if os.path.isfile(path):
        try:
            with open(path, 'r') as f:
                data = yaml.load(f)
        except (OSError, yaml.parser.ParserError) as e:
            raise PenderError("Couldn't load config: %s" % e)
        if not isinstance(data, dict):
            raise PenderError("Config toplevel isn't a mapping (dict).")
        # Load stubs if any sections are missing
        for section in ('pender', 'plugins'):
            if section not in data:
                data[section] = {}
        return data


def initialise_logging():
    """Initialise logging."""
    if 'PENDER_DEBUG' in os.environ:
        level = logging.DEBUG
    else:
        level = logging.INFO
    fmt = PenderLoggingFormatter()
    hdlr = logging.StreamHandler(sys.stdout)
    hdlr.setFormatter(fmt)
    logging.root.addHandler(hdlr)
    logging.root.setLevel(level)


def install_check(plugin_dir):
    """Ask if Pender should be installed."""
    source_path = sys.argv[0]
    repo_dir = os.path.dirname(source_path)
    install_q = "Install this pre-commit hook to {repo_dir}" \
                "/.git/hooks/pre-commit [Y/n]? "
    choice = raw_input(install_q.format(repo_dir=repo_dir))
    if choice in ('', 'Y', 'y', 'YES', 'yes', 'Yes'):
        dest_path = os.path.join(repo_dir, ".git/hooks/pre-commit")
        logging.debug("Installing to dest_path %s", dest_path)
        try:
            shutil.copyfile(source_path, dest_path)
            shutil.copystat(source_path, dest_path)
        except StandardError as err:
            logging.error("Failed! (%s)", err)
            return PENDER_EXIT_ERR
    else:
        return PENDER_EXIT_ERR
    install_plugins(plugin_dir)
    return PENDER_EXIT_OK


def autoupdate_check():
    """See if the repo version of Pender is newer, and fail if so."""
    git_dir = os.path.join(os.environ['GIT_DIR'])
    pender_repo_path = os.path.join(git_dir, '..', PENDER_NAME)
    pender_hook_path = os.path.join(git_dir, 'hooks', 'pre-commit')
    logging.debug("Comparing %s to %s", pender_repo_path, pender_hook_path)
    if os.stat(pender_repo_path).st_mtime > os.stat(pender_hook_path).st_mtime:
        logging.error("%s has been updated, please run the repository's "
                      "copy to update your installed version.", PENDER_NAME)
        sys.exit(1)


def install_plugins(plugin_dir):
    """Run plugin install checks."""
    for plugin in plugins(plugin_dir):
        plugin_install(plugin)


def changed_files():
    """Iterable of changed files."""
    changed_files_cmd = ['git', 'diff-index', '--diff-filter=AM',
                         '--name-only', '--cached', 'HEAD']
    try:
        files = subprocess.check_output(changed_files_cmd).splitlines()
    except subprocess.CalledProcessError as err:
        raise PenderError(
            "Couldn't determine changed files! Git error was:\n$ %s\n%s",
            ' '.join(changed_files_cmd), err.output)
    logging.debug("%s changed files: %s", len(files), ", ".join(files))
    return files


def create_temp_file(temp_tree, index_file):
    """Copy staged changes of index_file to same location in temp_tree."""
    git_args = ['git', 'cat-file', 'blob', ':0:{}'.format(index_file)]
    repo_path = os.path.dirname(index_file).lstrip('/')
    temp_dirpath = os.path.join(temp_tree, repo_path)

    if repo_path and not os.path.isdir(temp_dirpath):
        os.makedirs(temp_dirpath, mode=0o700)

    # We can't use check_output here, since we want to capture stderr
    # for error diagnostics but check_output can only do so by merging into
    # stdout (which we're using).
    temp_file = os.path.join(temp_dirpath, os.path.basename(index_file))
    with open(temp_file, 'w') as dest:
        try:
            git = subprocess.Popen(git_args,
                                   stdout=dest,
                                   stderr=subprocess.PIPE)
        except OSError as e:
            raise PenderError("Couldn't create temp file for %s (%s)" %
                              (index_file, e))
        _, stderr = git.communicate()
        if git.returncode:
            raise PenderError(stderr)
    logging.debug("Created temp file %s", temp_file)
    return temp_file


def plugins(plugin_dir):
    """Iterable of available plugins."""
    for path in os.listdir(plugin_dir):
        plugin = os.path.join(plugin_dir, path)
        if not os.path.isfile(plugin):
            logging.info("Non-file in plugin directory: %s", plugin)
            continue
        elif not os.access(plugin, os.X_OK):
            logging.info("Non-executable file in plugin directory: %s", plugin)
            continue
        yield plugin


def get_mime_type(path):
    """Return mime type of f (application/octet-stream if unknown)."""
    try:
        file_args = ['file', '--brief', '--mime-type', path]
        mime_type = subprocess.check_output(file_args).strip()
    except (subprocess.CalledProcessError, OSError) as err:
        logging.info("Couldn't determine MIME type of %s (\"%s\").", path, err)
        mime_type = 'application/octet-stream'
    return mime_type


def plugin_install(path):
    """Run plugin install and log any output."""
    args = (path, 'install')
    try:
        logging.debug("Running %s", args)
        output = subprocess.check_output(args, stderr=subprocess.STDOUT)
        for line in output.splitlines():
            logging.info("%s: %s", path, line)
    except subprocess.CalledProcessError as e:
        logging.error("%s failed during setup. Output:\n%s", path, e.output)


def plugin_check(path, real_file, temp_file, mime_type, env):
    """Run plugin and return (veto, output)."""
    args = (path, 'check', real_file, temp_file, mime_type)
    try:
        logging.debug("Running %s", args)
        plugin = subprocess.Popen(args,
                                  stderr=subprocess.STDOUT,
                                  stdout=subprocess.PIPE,
                                  env=env)
    except OSError as err:
        logging.warning("Couldn't run %s (%s), skipping.", plugin, err)
        return (False, '')
    output, _ = plugin.communicate()
    if plugin.returncode == PENDER_EXIT_OK:
        return (False, output)
    elif plugin.returncode == PENDER_EXIT_VETO:
        return (True, output)
    else:
        logging.warning("%s returned unexpected exit code %s, skipping.",
                        plugin, plugin.returncode)
        return (False, output)


def plugin_env(plugin_path, plugin_config):
    """Generate the environment for a particular plugin."""
    name = os.path.splitext(os.path.basename(plugin_path))[0]
    if name in plugin_config:
        env = os.environ.copy()
        if plugin_config[name]:
            for key, value in plugin_config[name].iteritems():
                logging.debug("Adding %s to environment for %s", key, name)
                env["PENDER_%s" % key] = str(value)
    else:
        env = os.environ
    return env


def process_changed_files(temp_tree, plugin_dir, plugin_config):
    """Process each changed file."""
    errors = 0
    for index_file in changed_files():
        logging.debug("Checking %s...", index_file)
        try:
            temp_file = create_temp_file(temp_tree, index_file)
        except PenderError as e:
            logging.error(e)
            errors += 1
            continue
        mime_type = get_mime_type(index_file)

        plugin_errors = False
        for plugin in plugins(plugin_dir):
            env = plugin_env(plugin, plugin_config)
            veto, output = plugin_check(plugin, index_file, temp_file,
                                        mime_type, env)
            if veto:
                plugin_errors = True
                logging.error("%s vetoes %s:", os.path.basename(plugin),
                              index_file)
            for line in output.splitlines():
                logging.info(line)
        if plugin_errors:
            errors += 1

    if errors:
        logging.error("Found errors in %s files, aborting commit.", errors)
        return GIT_EXIT_VETO
    else:
        return GIT_EXIT_OK


def main():
    """Main application."""
    initialise_logging()
    try:
        config = load_config()
    except PenderError as e:
        logging.error(e)
        sys.exit(GIT_EXIT_VETO)
    if config['pender'].get('debug'):
        logging.root.setLevel(logging.DEBUG)

    if 'GIT_DIR' not in os.environ:
        rc = install_check(config['pender']['plugin_dir'])
    else:
        autoupdate_check()
        try:
            temp_tree = tempfile.mkdtemp()
            rc = process_changed_files(temp_tree,
                                       config['pender']['plugin_dir'],
                                       config['plugins'])
        except KeyboardInterrupt:
            sys.stdout.flush()
            rc = GIT_EXIT_VETO
        except PenderError as e:
            logging.error(e)
            rc = GIT_EXIT_VETO
        finally:
            shutil.rmtree(temp_tree)
    sys.exit(rc)


if __name__ == '__main__':
    main()
